####Due date : 17:00 04/29/2022
####Raise a PR to: https://github.com/TAIsRich/chuwa4.1ShortQuestions.git
#####Remember PR to the branch names with your name
####What is POJO and what is Java Bean? What are the differences?
Ans：POJO（Plain Ordinary Java Object) basically define an entity such as getter, setter method.
All JavaBeans are POJOs but not all POJOs are JavaBeans. and provides complete control on members,
**difference**:
A JavaBean follows certain conventions. Getter/setter naming, having a public default constructor, being serialisable etc. 

A POJO (plain-old-Java-object) isn't rigorously defined. It's a Java object that doesn't have a requirement to implement a particular interface or derive from a particular base class, or make use of particular annotations in order to be compatible with a given framework, and can be any arbitrary (often relatively simple) Java object.

####What is Hibernate and why we need Hibernate?
Ans:Hibernate is framework of ORM(Object Relative Mapping) hat provides abstraction on multiple technologies like JDBC, servlet, etc.
 The implementations include tasks like writing a query for CRUD operations or establishing a connection with the databases, etc.
Advance:
Hibernate supports a variety of technologies, sucn as XDoclet Spring，Maven，Eclipse Plug-ins，J2EE
Lightweight and open-source,increased performance by using cache memory helping, database independence, automatic table creation（Auto DDL Operations ）

####What is ORM? Why it is helpful?
ans:Object/Relational Mapping is a technique that lets you query and manipulate data from a database using an object-oriented paradigm.
Pros:
Using ORM saves a lot of time,Using an ORM library is more flexibl
cons:But ORM can be a pain:have to learn it, and ORM libraries are not lightweight tools;

####What is Connection Pool? what is the advantage?
Ans: Connection pooling is a technique of creating and managing a pool of connections that are ready for use by any thread that needs them. 
Pros: it can greatly increase the performance of your Java application, while reducing overall resource usage.

####List all of the annotations about Entity.
Ans:
JPA Annotations
1. @Access
2. @AssociationOverride
3. @AssociationOverrides
4. @AttributeOverride
5. @AttributeOverrides
6. @Basic
7. @Cacheable
8. @CollectionTable
9. @Column
10. @ColumnResult
11. @ConstructorResult
12. @Convert
13. @Converter
14. @Converts
15. @DiscriminatorColumn
16. @DiscriminatorValue
17. @ElementCollection
18. @Embeddable
19. @Embedded
20. @EmbeddedId
21. @Entity
22. @EntityListeners
23. @EntityResult
24. @Enumerated
25. @ExcludeDefaultListeners
26. @ExcludeSuperclassListeners
27. @FieldResult
28. @ForeignKey
29. @GeneratedValue
30. @Id
31. @IdClass
32. @Index
33. @Inheritance
34. @JoinColumn
35. @JoinColumns
36. @JoinTable
37. @Lob
38. @ManyToMany
39. @ManyToOne
40. @MapKey
41. @MapKeyClass
42. @MapKeyColumn
43. @MapKeyEnumerated
44. @MapKeyJoinColumn
45. @MapKeyJoinColumns
46. @MapKeyTemporal
47. @MappedSuperclass
48. @MapsId
49. @NamedAttributeNode
50. @NamedEntityGraph
51. @NamedEntityGraphs
52. @NamedNativeQueries
53. @NamedNativeQuery
54. @NamedQueries
55. @NamedQuery
56. @NamedStoredProcedureQueries
57. @NamedStoredProcedureQuery
58. @NamedSubgraph
59. @OneToMany
60. @OneToOne
61. @OrderBy
62. @OrderColumn
63. @PersistenceContext
64. @PersistenceContexts
65. @PersistenceProperty
66. @PersistenceUnit
67. @PersistenceUnits
68. @PostLoad
69. @PostPersist
70. @PostRemove
71. @PostUpdate
72. @PrePersist
73. @PreRemove
74. @PreUpdate
75. @PrimaryKeyJoinColumn
76. @PrimaryKeyJoinColumns
77. @QueryHint
78. @SecondaryTable
79. @SecondaryTables
80. @SequenceGenerator
81. @SqlResultSetMapping
82. @SqlResultSetMappings
83. @StoredProcedureParameter
84. @Table
85. @TableGenerator
86. @Temporal
87. @Transient
88. @UniqueConstraint
89. @Version

####What is the JPA Naming conversation? (check below pictures)
？？
####How many JPA methods you know, list all. (check below pictures)

|Modifier and Type|Method and Description|
|:----------------|---------------------:|
|void|deleteAllByIdInBatch(Iterable<ID> ids)Deletes the entities identified by the given ids using a single query.|
|void|deleteAllInBatch()Deletes all entities in a batch call. |
|void|deleteAllInBatch(Iterable<T> entities) Deletes the given entities in a batch which means it will create a single query. |
|default void|deleteInBatch(Iterable<T> entities) Deprecated.  Use deleteAllInBatch(Iterable) instead.|
|<S extends T>List<S>|saveAll(Iterable<S> entities) |
####How to write your own query with parameter?
ans：pass parameters in a data source back to the underlying query
####What is pagination? (check below pictures)
ans：Pagination consist of two fields – page size and page number. 
Design two entities and the repository
Employee(you can add more fields)
id
firstname
lastname
title
join_date
create_date
update_date
```
package com.example.code1.entity;
import lombok.Data;
import javax.persistence.*;

@Data
@Entity
@Table(name="employees")
public class Employee {
    @Id  //定主键
    @GeneratedValue(strategy = GenerationType.AUTO) //为一个实体乘车一个唯一的表示主键，
   /* AUTO主键由程序控制, 是默认选项 ,不设置就是这个
    IDENTITY 主键由数据库生成, 采用数据库自增长, Oracle不支持这种方式
    SEQUENCE 通过数据库的序列产生主键, MYSQL  不支持
    Table 提供特定的数据库产生主键, 该方式更有利于数据库的移植*/
    private  Integer id;

    @Column(name="firstname")
    private String firstname;

    @Column(name="lastname")
    private String lastname;

    @Column(name="title")
    private String title;

    @Column(name="join_date", columnDefinition = "JOIN THE DATE")
    private String join_date;

    @Column(name="create_date", columnDefinition = "CREATE THE  NEW DATE")
    private String create_date;

    @Column(name="update_date", columnDefinition = "JOIN THE DATE")
    private String update_date;
}

```
order
id
product_name
amount
unit_price
create_date
update_date
```
package com.example.code1.entity;
import lombok.Data;
import javax.persistence.*;

@Entity
@Data
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;

    @Column(name="product_name")
    private String productName;

    @Column(name="amount")
    private double unitPrice;

    @Column(name="create_date", columnDefinition = "CREATE THE  NEW DATE")
    private String create_date;

    @Column(name="update_date", columnDefinition = "JOIN THE DATE")
    private String update_date;
}

```
EmployeeRepository
```
package com.example.code1.repository;
import com.example.code1.entity.Employee;
import org.springframework.data.jpa.repository.JpaRepository;

public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
    Employee findById(Long id);

    @Override
    void deleteAll();
    Employee save(Employee e);
    void  update(Employee e);
}

```
OrderRepository
```
package com.example.code1.entity;
import lombok.Data;
import javax.persistence.*;

@Entity
@Data
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;

    @Column(name="product_name")
    private String productName;

    @Column(name="amount")
    private double unitPrice;

    @Column(name="create_date", columnDefinition = "CREATE THE  NEW DATE")
    private String create_date;

    @Column(name="update_date", columnDefinition = "JOIN THE DATE")
    private String update_date;
}
```
In your repository code, list all of the CRUD methods from JPA for EmployeeRepository and OrderRepository

