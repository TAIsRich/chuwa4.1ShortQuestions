## What is POJO and what is Java Bean? What are the differences?

Ref# https://www.baeldung.com/java-pojo-class

POJO: Plain Old Java Object. When we describing POJO, which is a straightforward type with no references to any particular frameworks. A POJO has no naming convention for our properties and methods. 

The lack of convention causes two problems: 
It increases the learning curve for coders trying to understand how to use it. 
Limit a framework's ability to favor convention over configuration, understang how to use the class, and augment its functionality. 

Java Bean is still a POJO but introduces a strict set of rules around how we implement it: 
Access levels - our properties are private and we expose getters and setters 
Method names - our getters and setters follow the getX and setX convention (in the case of boolean. isX can be used for getter)
Default Constructor - a no-argument constructor must be present so an instance can be created without providing arguments, for example during deserialization 
Serializable - implementaing the Serializable interface allows us to store the state 

Tradeoffs when using JavaBeans 
When we use JavaBeans we should also be mindful of some potential disadvantages: 
Mutability - our JavaBeans are mutable due to their setter methods - this could lead to concurrency or consistency issues 
Boilerplate - we must introduce getters for all properties and setters for most, much of this must be unnecessary 
Zero-argument Constructor - we often need arguments in our constructors to ensure the object gets instantiated in a valid state, but the JavaBean standard requries us to provide a zero-argument constructor 

POJO is a Java object that is bound to no specific framework, and that a JavaBean is a special type of POJO with a strict set of conventions. 

## What is Hibernate and why we need Hibernate? 

Ref: https://www.theserverside.com/definition/Hibernate
Hibernate is an open source object relational mapping (ORM) tool that provides a framework to map object-oriented domain models to relational databases for web applications. 

ORM is based on the containerization of objects and the abstraction that provides that capacity. Abstraction makes it possible to address, access and manipulate objects without having to consider how they are related to their data sources. 

The Hibernate ORM framework guides mapping Java classes to database tables and Java data types to SQL data types and provides querying and retrieval. 

Benefits of Hibernate: 
Any changes made are encapsulated in the data source itself, so that when those sources or their applciation programming interfaces (APIs) change, the applications that use ORM don't have to make changes or even be aware of that information. Similarly, programmers can have a consistent view of objects over time, although the sources that deliver them, the sinks that receive them and the applications that access them may change. 

Hibernate reduces lines of code by maintaining object-table mapping itself and returns result to application in form of Java objects. It relieves programmer from manual handlign of persistent data, hence reducing the development time and maintenance cost. 

## What is ORM? Why it is helpful? 

## What is Connection Pool? What is the advantage? 

## List all of the annotations about Entity? 

## What is the JPA Naming conversation? 

## How many JPA methods you know, list all. 

## How to write your own query with parameter? 

## What is pagination? 

## Design two entites and the repository 
   a. Employee  i. id  ii. firstname   iii. lastname  iv. title v. join_date 
    vi. create_date vii. uddate_date 

   b. order id. id ii. product_name iii. amount iv. unit_price  v. create_date  vi. update_date 

   c. EmployeeRepository 
   d. OrderRepository 
   e. In your repository code, list all of the CRUD methods from JPAF for EmployeeRepository and OrderRepository 
   
    



